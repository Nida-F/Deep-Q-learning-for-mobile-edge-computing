# -*- coding: utf-8 -*-
"""Deep Reinforcement Learning for Task Offloading in Mobile Edge Computing Systems

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DFIMQ8MPG1AMk9of8J-6VcteeJGrZhDT
"""

import numpy as np
import tensorflow as tf
# import matplotlib.pyplot as plt
from collections import deque

class DeepQNetwork:

    def __init__(self,
                 n_actions,                  # the number of actions
                 n_features,
                 n_lstm_features,
                 n_time,
                 learning_rate = 0.01,
                 reward_decay = 0.9,
                 e_greedy = 0.99,
                 replace_target_iter = 200,  # each 200 steps, update target net
                 memory_size = 500,  # maximum of memory
                 batch_size=32,
                 e_greedy_increment= 0.00025,
                 n_lstm_step = 10,
                 dueling = True,
                 double_q = True,
                 N_L1 = 20,
                 N_lstm = 20):

        self.n_actions = n_actions
        self.n_features = n_features
        self.n_time = n_time
        self.lr = learning_rate
        self.gamma = reward_decay
        self.epsilon_max = e_greedy
        self.replace_target_iter = replace_target_iter
        self.memory_size = memory_size
        self.batch_size = batch_size    # select self.batch_size number of time sequence for learning
        self.epsilon_increment = e_greedy_increment
        self.epsilon = 0 if e_greedy_increment is not None else self.epsilon_max
        self.dueling = dueling
        self.double_q = double_q
        self.learn_step_counter = 0
        self.N_L1 = N_L1

        # lstm
        self.N_lstm = N_lstm
        self.n_lstm_step = n_lstm_step       # step_size in lstm
        self.n_lstm_state = n_lstm_features  # [fog1, fog2, ...., fogn, M_n(t)]

        # initialize zero memory np.hstack((s, [a, r], s_, lstm_s, lstm_s_))
        self.memory = np.zeros((self.memory_size, self.n_features + 1 + 1
                                    + self.n_features + self.n_lstm_state + self.n_lstm_state))

        # consist of [target_net, evaluate_net]
        self._build_net()

        # replace the parameters in target net
        t_params =tf.compat.v1.get_collection('target_net_params')  # obtain the parameters in target_net
        e_params = tf.compat.v1.get_collection('eval_net_params')  # obtain the parameters in eval_net
        self.replace_target_op = [tf.compat.v1.assign(t, e) for t, e in
                                      zip(t_params, e_params)]  # update the parameters in target_net

        self.sess = tf.compat.v1.Session()

        self.sess.run(tf.compat.v1.global_variables_initializer())
        self.reward_store = list()
        self.action_store = list()
        self.delay_store = list()

        self.lstm_history = deque(maxlen=self.n_lstm_step)
        for ii in range(self.n_lstm_step):
            self.lstm_history.append(np.zeros([self.n_lstm_state]))

        self.store_q_value = list()

    def _build_net(self):

        tf.compat.v1.reset_default_graph()

        def build_layers(s,lstm_s,c_names, n_l1, n_lstm, w_initializer, b_initializer):

            # lstm for load levels
            with tf.compat.v1.variable_scope('l0'):
                #lstm_dnn = tf.compat.v1.estimator.rnn.BasicLSTMCell(n_lstm)   tf.compat.v1.nn.rnn_cell.LSTMCell 
                lstm_dnn = tf.compat.v1.nn.rnn_cell.LSTMCell(n_lstm) 
                lstm_dnn.zero_state(self.batch_size, tf.compat.v1.float32)
                lstm_output,lstm_state = tf.compat.v1.nn.dynamic_rnn(lstm_dnn, lstm_s, dtype=tf.float32)
                lstm_output_reduced = tf.compat.v1.reshape(lstm_output[:, -1, :], shape=[-1, n_lstm])

            # first layer
            with tf.compat.v1.variable_scope('l1'):
                w1 =tf.compat.v1.get_variable('w1',[n_lstm + self.n_features, n_l1], initializer=w_initializer,
                                     collections=c_names)
                b1 = tf.compat.v1.get_variable('b1',[1,n_l1],initializer=b_initializer, collections=c_names)
                l1 = tf.compat.v1.nn.relu(tf.compat.v1.matmul(tf.compat.v1.concat([lstm_output_reduced, s],1), w1) + b1)

            # second layer
            with tf.compat.v1.variable_scope('l12'):
                w12 = tf.compat.v1.get_variable('w12', [n_l1, n_l1], initializer=w_initializer,
                                         collections=c_names)
                b12 = tf.compat.v1.get_variable('b12', [1, n_l1], initializer=b_initializer, collections=c_names)
                l12 = tf.compat.v1.nn.relu(tf.compat.v1.matmul(l1, w12) + b12)

            # the second layer is different
            if self.dueling:
                # Dueling DQN
                # a single output n_l1 -> 1
                with tf.compat.v1.variable_scope('Value'):
                    w2 = tf.compat.v1.get_variable('w2',[n_l1,1],initializer=w_initializer,collections=c_names)
                    b2 = tf.compat.v1.get_variable('b2',[1,1],initializer=b_initializer,collections=c_names)
                    self.V = tf.compat.v1.matmul(l12,w2) + b2
                # n_l1 -> n_actions
                with tf.compat.v1.variable_scope('Advantage'):
                    w2 = tf.compat.v1.get_variable('w2',[n_l1,self.n_actions],initializer=w_initializer,collections=c_names)
                    b2 = tf.compat.v1.get_variable('b2',[1,self.n_actions],initializer=b_initializer,collections=c_names)
                    self.A = tf.compat.v1.matmul(l12,w2) + b2

                with tf.compat.v1.variable_scope('Q'):
                    out = self.V + (self.A - tf.compat.v1.reduce_mean(self.A,axis=1,keep_dims=True))  # Q = V(s) +A(s,a)

            else:
                with tf.compat.v1.variable_scope('Q'):
                    w2 = tf.compat.v1.get_variable('w2', [n_l1, self.n_actions], initializer=w_initializer, collections=c_names)
                    b2 = tf.compat.v1.get_variable('b2', [1, self.n_actions], initializer=b_initializer, collections=c_names)
                    out = tf.compat.v1.matmul(l1, w2) + b2

            return out

        # input for eval_net
        self.s = tf.compat.v1.placeholder(tf.compat.v1.float32,[None,self.n_features], name = 's')  # state (observation)
        self.lstm_s = tf.compat.v1.placeholder(tf.compat.v1.float32,[None,self.n_lstm_step,self.n_lstm_state], name='lstm1_s')

        self.q_target = tf.compat.v1.placeholder(tf.compat.v1.float32,[None,self.n_actions], name = 'Q_target') # q_target

        # input for target_net
        self.s_ = tf.compat.v1.placeholder(tf.compat.v1.float32, [None, self.n_features], name='s_')
        self.lstm_s_ = tf.compat.v1.placeholder(tf.float32,[None,self.n_lstm_step,self.n_lstm_state], name='lstm1_s_')

        # generate EVAL_NET, update parameters
        with tf.compat.v1.variable_scope('eval_net'):

            # c_names(collections_names), will be used when update target_net
            # tf.random_normal_initializer(mean=0.0, stddev=1.0, seed=None, dtype=tf.float32), return a initializer
            c_names, n_l1, n_lstm, w_initializer, b_initializer =  \
                ['eval_net_params', tf.compat.v1.GraphKeys.GLOBAL_VARIABLES], self.N_L1, self.N_lstm,\
                tf.compat.v1.random_normal_initializer(0., 0.3), tf.compat.v1.constant_initializer(0.1)  # config of layers

            # input (n_feature) -> l1 (n_l1) -> l2 (n_actions)
            self.q_eval = build_layers(self.s, self.lstm_s, c_names, n_l1, n_lstm, w_initializer, b_initializer)

        # generate TARGET_NET
        with tf.compat.v1.variable_scope('target_net'):
            c_names = ['target_net_params', tf.compat.v1.GraphKeys.GLOBAL_VARIABLES]

            self.q_next = build_layers(self.s_, self.lstm_s_, c_names, n_l1, n_lstm, w_initializer, b_initializer)

        # loss and train
        with tf.compat.v1.variable_scope('loss'):
            self.loss = tf.compat.v1.reduce_mean(tf.compat.v1.squared_difference(self.q_target,self.q_eval))
        with tf.compat.v1.variable_scope('train'):
            self._train_op = tf.compat.v1.train.RMSPropOptimizer(self.lr).minimize(self.loss)

    def store_transition(self, s, lstm_s,  a, r, s_, lstm_s_):
        # RL.store_transition(observation,action,reward,observation_)
        # hasattr(object, name), if object has name attribute
        if not hasattr(self, 'memory_counter'):
            self.memory_counter = 0

        # store np.hstack((s, [a, r], s_, lstm_s, lstm_s_))
        transition = np.hstack((s, [a, r], s_, lstm_s, lstm_s_))  # stack in horizontal direction

        # if memory overflows, replace old memory with new one
        index = self.memory_counter % self.memory_size
        # print(transition)
        self.memory[index, :] = transition
        self.memory_counter += 1

    def update_lstm(self, lstm_s):

        self.lstm_history.append(lstm_s)

    def choose_action(self, observation):
        # the shape of the observation (1, size_of_observation)
        # x1 = np.array([1, 2, 3, 4, 5]), x1_new = x1[np.newaxis, :], now, the shape of x1_new is (1, 5)
        observation = observation[np.newaxis, :]

        if np.random.uniform() < self.epsilon:

            # lstm only contains history, there is no current observation
            lstm_observation = np.array(self.lstm_history)

            actions_value = self.sess.run(self.q_eval,
                                          feed_dict={self.s: observation,
                                                     self.lstm_s: lstm_observation.reshape(1, self.n_lstm_step,
                                                                                           self.n_lstm_state),
                                                     })

            self.store_q_value.append({'observation': observation, 'q_value': actions_value})

            action = np.argmax(actions_value)

        else:

            action = np.random.randint(0, self.n_actions)

        return action

    def learn(self):

        # check if replace target_net parameters
        if self.learn_step_counter % self.replace_target_iter == 0:
            # run the self.replace_target_op in __int__
            self.sess.run(self.replace_target_op)
            print('\ntarget_params_replaced\n')

        # randomly pick [batch_size] memory from memory np.hstack((s, [a, r], s_, lstm_s, lstm_s_))
        if self.memory_counter > self.memory_size:
            sample_index = np.random.choice(self.memory_size - self.n_lstm_step, size=self.batch_size)
        else:
            sample_index = np.random.choice(self.memory_counter - self.n_lstm_step, size=self.batch_size)\

        #  transition = np.hstack(s, [a, r], s_, lstm_s, lstm_s_)
        batch_memory = self.memory[sample_index, :self.n_features+1+1+self.n_features]
        lstm_batch_memory = np.zeros([self.batch_size, self.n_lstm_step, self.n_lstm_state * 2])
        for ii in range(len(sample_index)):
            for jj in range(self.n_lstm_step):
                lstm_batch_memory[ii,jj,:] = self.memory[sample_index[ii]+jj,
                                              self.n_features+1+1+self.n_features:]

        # obtain q_next (from target_net) (to q_target) and q_eval (from eval_net)
        # minimize（target_q - q_eval）^2
        # q_target = reward + gamma * q_next
        # in the size of bacth_memory
        # q_next, given the next state from batch, what will be the q_next from q_next
        # q_eval4next, given the next state from batch, what will be the q_eval4next from q_eval
        q_next, q_eval4next = self.sess.run(
            [self.q_next, self.q_eval],  # output
            feed_dict={
                # [s, a, r, s_]
                # input for target_q (last)
                self.s_: batch_memory[:, -self.n_features:], self.lstm_s_: lstm_batch_memory[:,:,self.n_lstm_state:],
                # input for eval_q (last)
                self.s: batch_memory[:, -self.n_features:], self.lstm_s: lstm_batch_memory[:,:,self.n_lstm_state:],
            }
        )
        # q_eval, given the current state from batch, what will be the q_eval from q_eval
        q_eval = self.sess.run(self.q_eval, {self.s: batch_memory[:, :self.n_features],
                                                 self.lstm_s: lstm_batch_memory[:,:,:self.n_lstm_state]})
        q_target = q_eval.copy()
        batch_index = np.arange(self.batch_size, dtype=np.int32)
        eval_act_index = batch_memory[:, self.n_features].astype(int)  # action with a single value (int action)
        reward = batch_memory[:, self.n_features + 1]  # reward with a single value

        # update the q_target at the particular batch at the correponding action
        if self.double_q:
            max_act4next = np.argmax(q_eval4next, axis=1)
            selected_q_next = q_next[batch_index, max_act4next]
        else:
            selected_q_next = np.max(q_next, axis=1)

        q_target[batch_index, eval_act_index] = reward + self.gamma * selected_q_next

        # both self.s and self.q_target belong to eval_q
        # input self.s and self.q_target, output self._train_op, self.loss (to minimize the gap)
        # self.sess.run: given input (feed), output the required element
        _, self.cost = self.sess.run([self._train_op, self.loss],
                                     feed_dict={self.s: batch_memory[:, :self.n_features],
                                                self.lstm_s: lstm_batch_memory[:, :, :self.n_lstm_state],
                                                self.q_target: q_target})

        # gradually increase epsilon
        self.epsilon = self.epsilon + self.epsilon_increment if self.epsilon < self.epsilon_max else self.epsilon_max
        self.learn_step_counter += 1

    def do_store_reward(self, episode, time, reward):
        while episode >= len(self.reward_store):
            self.reward_store.append(np.zeros([self.n_time]))
        self.reward_store[episode][time] = reward

    def do_store_action(self,episode,time, action):
        while episode >= len(self.action_store):
            self.action_store.append(- np.ones([self.n_time]))
        self.action_store[episode][time] = action

    def do_store_delay(self, episode, time, delay):
        while episode >= len(self.delay_store):
            self.delay_store.append(np.zeros([self.n_time]))
        self.delay_store[episode][time] = delay

import numpy as np
import random
import math
import queue

class Offload:

    def __init__(self, num_iot, num_fog, num_time, max_delay):

        # INPUT DATA
        self.n_iot = num_iot
        self.n_fog = num_fog
        self.n_time = num_time
        self.duration = 0.1

        # test
        self.drop_trans_count = 0
        self.drop_fog_count = 0
        self.drop_iot_count = 0

        # CONSIDER A SCENARIO RANDOM IS NOT GOOD
        # LOCAL CAP SHOULD NOT BE TOO SMALL, OTHERWISE, THE STATE MATRIX IS TOO LARGE (EXCEED THE MAXIMUM)
        # SHOULD NOT BE LESS THAN ONE
        self.comp_cap_iot = 2.5 * np.ones(self.n_iot) * self.duration  # 2.5 Gigacycles per second  * duration
        self.comp_cap_fog = 41.8 * np.ones([self.n_fog]) * self.duration  # Gigacycles per second * duration
        self.tran_cap_iot = 14 * np.ones([self.n_iot, self.n_fog]) * self.duration  # Mbps * duration
        self.comp_density = 0.297 * np.ones([self.n_iot])  # 0.297 Gigacycles per Mbits
        self.max_delay = max_delay # time slots

        # BITARRIVE_SET (MARKOVIAN)
        self.task_arrive_prob = 0.3
        self.max_bit_arrive = 5 # Mbits
        self.min_bit_arrive = 2 # Mbits
        self.bitArrive_set = np.arange(self.min_bit_arrive, self.max_bit_arrive, 0.1)
        self.bitArrive = np.zeros([self.n_time, self.n_iot])

        # ACTION: 0, local; 1, fog 0; 2, fog 1; ...; n, fog n - 1
        self.n_actions = 1 + num_fog
        # STATE: [A, t^{comp}, t^{tran}, [B^{fog}]]
        self.n_features = 1 + 1 + 1 + num_fog
        # LSTM STATE
        self.n_lstm_state = self.n_fog  # [fog1, fog2, ...., fogn]

        # TIME COUNT
        self.time_count = int(0)

        # QUEUE INITIALIZATION: size -> task size; time -> arrive time
        self.Queue_iot_comp = list()
        self.Queue_iot_tran = list()
        self.Queue_fog_comp = list()

        for iot in range(self.n_iot):
            self.Queue_iot_comp.append(queue.Queue())
            self.Queue_iot_tran.append(queue.Queue())
            self.Queue_fog_comp.append(list())
            for fog in range(self.n_fog):
                self.Queue_fog_comp[iot].append(queue.Queue())

        # QUEUE INFO INITIALIZATION
        self.t_iot_comp = - np.ones([self.n_iot])
        self.t_iot_tran = - np.ones([self.n_iot])
        self.b_fog_comp = np.zeros([self.n_iot, self.n_fog])

        # TASK INDICATOR
        self.task_on_process_local = list()
        self.task_on_transmit_local = list()
        self.task_on_process_fog = list()
        self.fog_iot_m = np.zeros(self.n_fog)
        self.fog_iot_m_observe = np.zeros(self.n_fog)

        for iot in range(self.n_iot):
            self.task_on_process_local.append({'size': np.nan, 'time': np.nan, 'remain': np.nan})
            self.task_on_transmit_local.append({'size': np.nan, 'time': np.nan,
                                                'fog': np.nan, 'remain': np.nan})
            self.task_on_process_fog.append(list())
            for fog in range(self.n_fog):
                self.task_on_process_fog[iot].append({'size': np.nan, 'time': np.nan, 'remain': np.nan})

        # TASK DELAY
        self.process_delay = np.zeros([self.n_time, self.n_iot])    # total delay
        self.process_delay_unfinish_ind = np.zeros([self.n_time, self.n_iot])  # unfinished indicator
        self.process_delay_trans = np.zeros([self.n_time, self.n_iot])  # transmission delay (if applied)

        self.fog_drop = np.zeros([self.n_iot, self.n_fog])

    # reset the network scenario
    def reset(self, bitArrive):

        # test
        self.drop_trans_count = 0
        self.drop_fog_count = 0
        self.drop_iot_count = 0

        # BITRATE
        self.bitArrive = bitArrive

        # TIME COUNT
        self.time_count = int(0)

        # QUEUE INITIALIZATION
        self.Queue_iot_comp = list()
        self.Queue_iot_tran = list()
        self.Queue_fog_comp = list()

        for iot in range(self.n_iot):
            self.Queue_iot_comp.append(queue.Queue())
            self.Queue_iot_tran.append(queue.Queue())
            self.Queue_fog_comp.append(list())
            for fog in range(self.n_fog):
                self.Queue_fog_comp[iot].append(queue.Queue())

        # QUEUE INFO INITIALIZATION
        self.t_iot_comp = - np.ones([self.n_iot])
        self.t_iot_tran = - np.ones([self.n_iot])
        self.b_fog_comp = np.zeros([self.n_iot, self.n_fog])

        # TASK INDICATOR
        self.task_on_process_local = list()
        self.task_on_transmit_local = list()
        self.task_on_process_fog = list()

        for iot in range(self.n_iot):
            self.task_on_process_local.append({'size': np.nan, 'time': np.nan, 'remain': np.nan})
            self.task_on_transmit_local.append({'size': np.nan, 'time': np.nan,
                                                'fog': np.nan, 'remain': np.nan})
            self.task_on_process_fog.append(list())
            for fog in range(self.n_fog):
                self.task_on_process_fog[iot].append({'size': np.nan, 'time': np.nan, 'remain': np.nan})

        # TASK DELAY
        self.process_delay = np.zeros([self.n_time, self.n_iot])
        self.process_delay_unfinish_ind = np.zeros([self.n_time, self.n_iot])  # unfinished indicator
        self.process_delay_trans = np.zeros([self.n_time, self.n_iot])  # transmission delay (if applied)

        self.fog_drop = np.zeros([self.n_iot, self.n_fog])

        # INITIAL
        observation_all = np.zeros([self.n_iot, self.n_features])
        for iot_index in range(self.n_iot):
            # observation is zero if there is no task arrival
            if self.bitArrive[self.time_count, iot_index] != 0:
                # state [A, B^{comp}, B^{tran}, [B^{fog}]]
                observation_all[iot_index, :] = np.hstack([
                    self.bitArrive[self.time_count, iot_index], self.t_iot_comp[iot_index],
                    self.t_iot_tran[iot_index],
                    np.squeeze(self.b_fog_comp[iot_index, :])])

        lstm_state_all = np.zeros([self.n_iot, self.n_lstm_state])

        return observation_all, lstm_state_all

    # perform action, observe state and delay (several steps later)
    def step(self, action):

        # EXTRACT ACTION FOR EACH IOT
        iot_action_local = np.zeros([self.n_iot], np.int32)
        iot_action_fog = np.zeros([self.n_iot], np.int32)
        for iot_index in range(self.n_iot):
            iot_action = action[iot_index]
            iot_action_fog[iot_index] = int(iot_action - 1)
            if iot_action == 0:
                iot_action_local[iot_index] = 1

        # COMPUTATION QUEUE UPDATE ===================
        for iot_index in range(self.n_iot):

            iot_bitarrive = np.squeeze(self.bitArrive[self.time_count, iot_index])
            iot_comp_cap = np.squeeze(self.comp_cap_iot[iot_index])
            iot_comp_density = self.comp_density[iot_index]

            # INPUT
            if iot_action_local[iot_index] == 1:
                tmp_dict = {'size': iot_bitarrive, 'time': self.time_count}
                self.Queue_iot_comp[iot_index].put(tmp_dict)

            # TASK ON PROCESS
            if math.isnan(self.task_on_process_local[iot_index]['remain']) \
                    and (not self.Queue_iot_comp[iot_index].empty()):
                while not self.Queue_iot_comp[iot_index].empty():
                    # only put the non-zero task to the processor
                    get_task = self.Queue_iot_comp[iot_index].get()
                    # since it is at the beginning of the time slot, = self.max_delay is acceptable
                    if get_task['size'] != 0:
                        if self.time_count - get_task['time'] + 1 <= self.max_delay:
                            self.task_on_process_local[iot_index]['size'] = get_task['size']
                            self.task_on_process_local[iot_index]['time'] = get_task['time']
                            self.task_on_process_local[iot_index]['remain'] \
                                = self.task_on_process_local[iot_index]['size']
                            break
                        else:
                            self.process_delay[get_task['time'], iot_index] = self.max_delay
                            self.process_delay_unfinish_ind[get_task['time'], iot_index] = 1

            # PROCESS
            if self.task_on_process_local[iot_index]['remain'] > 0:
                self.task_on_process_local[iot_index]['remain'] = \
                    self.task_on_process_local[iot_index]['remain'] - iot_comp_cap / iot_comp_density
                # if no remain, compute processing delay
                if self.task_on_process_local[iot_index]['remain'] <= 0:
                    self.process_delay[self.task_on_process_local[iot_index]['time'], iot_index] \
                        = self.time_count - self.task_on_process_local[iot_index]['time'] + 1
                    self.task_on_process_local[iot_index]['remain'] = np.nan
                elif self.time_count - self.task_on_process_local[iot_index]['time'] + 1 == self.max_delay:
                    self.process_delay[self.task_on_process_local[iot_index]['time'], iot_index] = self.max_delay
                    self.process_delay_unfinish_ind[self.task_on_process_local[iot_index]['time'], iot_index] = 1
                    self.task_on_process_local[iot_index]['remain'] = np.nan

                    self.drop_iot_count = self.drop_iot_count + 1

            # OTHER INFO self.t_iot_comp[iot_index]
            # update self.t_iot_comp[iot_index] only when iot_bitrate != 0
            if iot_bitarrive != 0:
                tmp_tilde_t_iot_comp = np.max([self.t_iot_comp[iot_index] + 1, self.time_count])
                self.t_iot_comp[iot_index] = np.min([tmp_tilde_t_iot_comp
                                                    + math.ceil(iot_bitarrive * iot_action_local[iot_index]
                                                     / (iot_comp_cap / iot_comp_density)) - 1,
                                                    self.time_count + self.max_delay - 1])

        # FOG QUEUE UPDATE =========================
        for iot_index in range(self.n_iot):

            iot_comp_density = self.comp_density[iot_index]

            for fog_index in range(self.n_fog):

                # TASK ON PROCESS
                if math.isnan(self.task_on_process_fog[iot_index][fog_index]['remain']) \
                        and (not self.Queue_fog_comp[iot_index][fog_index].empty()):
                    while not self.Queue_fog_comp[iot_index][fog_index].empty():
                        get_task = self.Queue_fog_comp[iot_index][fog_index].get()
                        if self.time_count - get_task['time'] + 1 <= self.max_delay:
                            self.task_on_process_fog[iot_index][fog_index]['size'] \
                                = get_task['size']
                            self.task_on_process_fog[iot_index][fog_index]['time'] \
                                = get_task['time']
                            self.task_on_process_fog[iot_index][fog_index]['remain'] \
                                = self.task_on_process_fog[iot_index][fog_index]['size']
                            break
                        else:
                            self.process_delay[get_task['time'], iot_index] = self.max_delay
                            self.process_delay_unfinish_ind[get_task['time'], iot_index] = 1

                # PROCESS
                self.fog_drop[iot_index, fog_index] = 0
                if self.task_on_process_fog[iot_index][fog_index]['remain'] > 0:
                    self.task_on_process_fog[iot_index][fog_index]['remain'] = \
                        self.task_on_process_fog[iot_index][fog_index]['remain'] \
                        - self.comp_cap_fog[fog_index] / iot_comp_density / self.fog_iot_m[fog_index]
                    # if no remain, compute processing delay
                    if self.task_on_process_fog[iot_index][fog_index]['remain'] <= 0:
                        self.process_delay[self.task_on_process_fog[iot_index][fog_index]['time'],iot_index] \
                            = self.time_count - self.task_on_process_fog[iot_index][fog_index]['time'] + 1
                        self.task_on_process_fog[iot_index][fog_index]['remain'] = np.nan
                    elif self.time_count - self.task_on_process_fog[iot_index][fog_index]['time'] + 1 == self.max_delay:
                        self.process_delay[self.task_on_process_fog[iot_index][fog_index]['time'], iot_index] = \
                            self.max_delay
                        self.process_delay_unfinish_ind[self.task_on_process_fog[iot_index][fog_index]['time'],
                                                        iot_index] = 1
                        self.fog_drop[iot_index, fog_index] = self.task_on_process_fog[iot_index][fog_index]['remain']
                        self.task_on_process_fog[iot_index][fog_index]['remain'] = np.nan

                        self.drop_fog_count = self.drop_fog_count + 1

                # OTHER INFO
                if self.fog_iot_m[fog_index] != 0:
                    self.b_fog_comp[iot_index, fog_index] \
                        = np.max([self.b_fog_comp[iot_index, fog_index]
                                  - self.comp_cap_fog[fog_index] / iot_comp_density / self.fog_iot_m[fog_index]
                                  - self.fog_drop[iot_index, fog_index], 0])

        # TRANSMISSION QUEUE UPDATE ===================
        for iot_index in range(self.n_iot):

            iot_tran_cap = np.squeeze(self.tran_cap_iot[iot_index,:])
            iot_bitarrive = np.squeeze(self.bitArrive[self.time_count, iot_index])

            # INPUT
            if iot_action_local[iot_index] == 0:
                tmp_dict = {'size': self.bitArrive[self.time_count, iot_index], 'time': self.time_count,
                            'fog': iot_action_fog[iot_index]}
                self.Queue_iot_tran[iot_index].put(tmp_dict)

            # TASK ON PROCESS
            if math.isnan(self.task_on_transmit_local[iot_index]['remain']) \
                    and (not self.Queue_iot_tran[iot_index].empty()):
                while not self.Queue_iot_tran[iot_index].empty():
                    get_task = self.Queue_iot_tran[iot_index].get()
                    if get_task['size'] != 0:
                        if self.time_count - get_task['time'] + 1 <= self.max_delay:
                            self.task_on_transmit_local[iot_index]['size'] = get_task['size']
                            self.task_on_transmit_local[iot_index]['time'] = get_task['time']
                            self.task_on_transmit_local[iot_index]['fog'] = int(get_task['fog'])
                            self.task_on_transmit_local[iot_index]['remain'] = \
                                self.task_on_transmit_local[iot_index]['size']
                            break
                        else:
                            self.process_delay[get_task['time'], iot_index] = self.max_delay
                            self.process_delay_unfinish_ind[get_task['time'], iot_index] = 1

            # PROCESS
            if self.task_on_transmit_local[iot_index]['remain'] > 0:
                self.task_on_transmit_local[iot_index]['remain'] = \
                    self.task_on_transmit_local[iot_index]['remain'] \
                    - iot_tran_cap[self.task_on_transmit_local[iot_index]['fog']]

                # UPDATE FOG QUEUE
                if self.task_on_transmit_local[iot_index]['remain'] <= 0:
                    tmp_dict = {'size': self.task_on_transmit_local[iot_index]['size'],
                                'time': self.task_on_transmit_local[iot_index]['time']}
                    self.Queue_fog_comp[iot_index][self.task_on_transmit_local[iot_index]['fog']].put(tmp_dict)

                    # OTHER INFO
                    fog_index = self.task_on_transmit_local[iot_index]['fog']
                    self.b_fog_comp[iot_index, fog_index] \
                        = self.b_fog_comp[iot_index, fog_index] + self.task_on_transmit_local[iot_index]['size']
                    self.process_delay_trans[self.task_on_transmit_local[iot_index]['time'], iot_index] \
                        = self.time_count - self.task_on_transmit_local[iot_index]['time'] + 1
                    self.task_on_transmit_local[iot_index]['remain'] = np.nan

                elif self.time_count - self.task_on_transmit_local[iot_index]['time'] + 1 == self.max_delay:
                    self.process_delay[self.task_on_transmit_local[iot_index]['time'], iot_index] = self.max_delay
                    self.process_delay_trans[self.task_on_transmit_local[iot_index]['time'], iot_index] \
                        = self.max_delay
                    self.process_delay_unfinish_ind[self.task_on_transmit_local[iot_index]['time'], iot_index] = 1
                    self.task_on_transmit_local[iot_index]['remain'] = np.nan

                    self.drop_trans_count = self.drop_trans_count + 1

            # OTHER INFO
            if iot_bitarrive != 0:
                tmp_tilde_t_iot_tran = np.max([self.t_iot_tran[iot_index] + 1, self.time_count])
                self.t_iot_comp[iot_index] = np.min([tmp_tilde_t_iot_tran
                                                    + math.ceil(iot_bitarrive * (1 - iot_action_local[iot_index])
                                                     / iot_tran_cap[iot_action_fog[iot_index]]) - 1,
                                                    self.time_count + self.max_delay - 1])

        # COMPUTE CONGESTION (FOR NEXT TIME SLOT)
        self.fog_iot_m_observe = self.fog_iot_m
        self.fog_iot_m = np.zeros(self.n_fog)
        for fog_index in range(self.n_fog):
            for iot_index in range(self.n_iot):
                if (not self.Queue_fog_comp[iot_index][fog_index].empty()) \
                        or self.task_on_process_fog[iot_index][fog_index]['remain'] > 0:
                    self.fog_iot_m[fog_index] += 1

        # TIME UPDATE
        self.time_count = self.time_count + 1
        done = False
        if self.time_count >= self.n_time:
            done = True
            # set all the tasks' processing delay and unfinished indicator
            for time_index in range(self.n_time):
                for iot_index in range(self.n_iot):
                    if self.process_delay[time_index, iot_index] == 0 and self.bitArrive[time_index, iot_index] != 0:
                        self.process_delay[time_index, iot_index] = (self.time_count - 1) - time_index + 1
                        self.process_delay_unfinish_ind[time_index, iot_index] = 1

        # OBSERVATION
        observation_all_ = np.zeros([self.n_iot, self.n_features])
        lstm_state_all_ = np.zeros([self.n_iot, self.n_lstm_state])
        if not done:
            for iot_index in range(self.n_iot):
                # observation is zero if there is no task arrival
                if self.bitArrive[self.time_count, iot_index] != 0:
                    # state [A, B^{comp}, B^{tran}, [B^{fog}]]
                    observation_all_[iot_index, :] = np.hstack([
                        self.bitArrive[self.time_count, iot_index],
                        self.t_iot_comp[iot_index] - self.time_count + 1,
                        self.t_iot_tran[iot_index] - self.time_count + 1,
                        self.b_fog_comp[iot_index, :]])

                lstm_state_all_[iot_index, :] = np.hstack(self.fog_iot_m_observe)

        return observation_all_, lstm_state_all_, done

import numpy as np
import random
# import matplotlib.pyplot as plt
np.set_printoptions(threshold=np.inf)
tf.compat.v1.disable_eager_execution()


def random_pick(some_list, probabilities):
    x = random.uniform(0, 1)
    cumulative_probability = 0.0
    for item, item_probability in zip(some_list, probabilities):
        cumulative_probability += item_probability
        if x < cumulative_probability:
            break
    return item


def reward_fun(delay, max_delay, unfinish_indi):

    # still use reward, but use the negative value
    penalty = - max_delay * 2

    if unfinish_indi:
        reward = penalty
    else:
        reward = - delay

    return reward


def train(iot_RL_list, NUM_EPISODE):

    RL_step = 0

    for episode in range(NUM_EPISODE):

        print(episode)
        print(iot_RL_list[0].epsilon)
        # BITRATE ARRIVAL
        bitarrive = np.random.uniform(env.min_bit_arrive, env.max_bit_arrive, size=[env.n_time, env.n_iot])
        task_prob = env.task_arrive_prob
        bitarrive = bitarrive * (np.random.uniform(0, 1, size=[env.n_time, env.n_iot]) < task_prob)
        bitarrive[-env.max_delay:, :] = np.zeros([env.max_delay, env.n_iot])

        # =================================================================================================
        # ========================================= DRL ===================================================
        # =================================================================================================

        # OBSERVATION MATRIX SETTING
        history = list()
        for time_index in range(env.n_time):
            history.append(list())
            for iot_index in range(env.n_iot):
                tmp_dict = {'observation': np.zeros(env.n_features),
                            'lstm': np.zeros(env.n_lstm_state),
                            'action': np.nan,
                            'observation_': np.zeros(env.n_features),
                            'lstm_': np.zeros(env.n_lstm_state)}
                history[time_index].append(tmp_dict)
        reward_indicator = np.zeros([env.n_time, env.n_iot])

        # INITIALIZE OBSERVATION
        observation_all, lstm_state_all = env.reset(bitarrive)

        # TRAIN DRL
        while True:

            # PERFORM ACTION
            action_all = np.zeros([env.n_iot])
            for iot_index in range(env.n_iot):

                observation = np.squeeze(observation_all[iot_index, :])

                if np.sum(observation) == 0:
                    # if there is no task, action = 0 (also need to be stored)
                    action_all[iot_index] = 0
                else:
                    action_all[iot_index] = iot_RL_list[iot_index].choose_action(observation)

                if observation[0] != 0:
                    iot_RL_list[iot_index].do_store_action(episode, env.time_count, action_all[iot_index])

            # OBSERVE THE NEXT STATE AND PROCESS DELAY (REWARD)
            observation_all_, lstm_state_all_, done = env.step(action_all)

            # should store this information in EACH time slot
            for iot_index in range(env.n_iot):
                iot_RL_list[iot_index].update_lstm(lstm_state_all_[iot_index,:])

            process_delay = env.process_delay
            unfinish_indi = env.process_delay_unfinish_ind

            # STORE MEMORY; STORE TRANSITION IF THE TASK PROCESS DELAY IS JUST UPDATED
            for iot_index in range(env.n_iot):

                history[env.time_count - 1][iot_index]['observation'] = observation_all[iot_index, :]
                history[env.time_count - 1][iot_index]['lstm'] = np.squeeze(lstm_state_all[iot_index, :])
                history[env.time_count - 1][iot_index]['action'] = action_all[iot_index]
                history[env.time_count - 1][iot_index]['observation_'] = observation_all_[iot_index]
                history[env.time_count - 1][iot_index]['lstm_'] = np.squeeze(lstm_state_all_[iot_index,:])

                update_index = np.where((1 - reward_indicator[:,iot_index]) * process_delay[:,iot_index] > 0)[0]

                if len(update_index) != 0:
                    for update_ii in range(len(update_index)):
                        time_index = update_index[update_ii]
                        iot_RL_list[iot_index].store_transition(history[time_index][iot_index]['observation'],
                                                                history[time_index][iot_index]['lstm'],
                                                                history[time_index][iot_index]['action'],
                                                                reward_fun(process_delay[time_index, iot_index],
                                                                           env.max_delay,
                                                                           unfinish_indi[time_index, iot_index]),
                                                                history[time_index][iot_index]['observation_'],
                                                                history[time_index][iot_index]['lstm_'])
                        iot_RL_list[iot_index].do_store_reward(episode, time_index,
                                                               reward_fun(process_delay[time_index, iot_index],
                                                                          env.max_delay,
                                                                          unfinish_indi[time_index, iot_index]))
                        iot_RL_list[iot_index].do_store_delay(episode, time_index,
                                                              process_delay[time_index, iot_index])
                        reward_indicator[time_index, iot_index] = 1

            # ADD STEP (one step does not mean one store)
            RL_step += 1

            # UPDATE OBSERVATION
            observation_all = observation_all_
            lstm_state_all = lstm_state_all_

            # CONTROL LEARNING START TIME AND FREQUENCY
            if (RL_step > 200) and (RL_step % 10 == 0):
                for iot in range(env.n_iot):
                    iot_RL_list[iot].learn()

            # GAME ENDS
            if done:
                break
        #  =================================================================================================
        #  ======================================== DRL END=================================================
        #  =================================================================================================


if __name__ == "__main__":

    NUM_IOT = 50
    NUM_FOG = 5
    NUM_EPISODE = 1000
    NUM_TIME_BASE = 100
    MAX_DELAY = 10
    NUM_TIME = NUM_TIME_BASE + MAX_DELAY

    # GENERATE ENVIRONMENT
    env = Offload(NUM_IOT, NUM_FOG, NUM_TIME, MAX_DELAY)

    # GENERATE MULTIPLE CLASSES FOR RL
    iot_RL_list = list()
    for iot in range(NUM_IOT):
        iot_RL_list.append(DeepQNetwork(env.n_actions, env.n_features, env.n_lstm_state, env.n_time,
                                        learning_rate=0.01,
                                        reward_decay=0.9,
                                        e_greedy=0.99,
                                        replace_target_iter=200,  # each 200 steps, update target net
                                        memory_size=500,  # maximum of memory
                                        ))

    # TRAIN THE SYSTEM
    train(iot_RL_list, NUM_EPISODE)
    print('Training Finished')